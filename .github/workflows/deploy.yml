name: Deploy to ECS (image-only rollout, keys)

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]
    paths:
      - "app.py"
      - "Dockerfile"
      - "requirements.txt"
      - ".github/workflows/deploy.yml"

permissions:
  contents: read

env:
  AWS_REGION: ap-northeast-1
  AWS_ACCOUNT_ID: "291234479055"
  ECR_REPO: voicebot
  CLUSTER: voicebot-cluster
  SERVICE: svc-voicebot
  CONTAINER_NAME: voicebot

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region "${AWS_REGION}" \
            | docker login --username AWS --password-stdin "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Ensure ECR repository exists
        run: |
          aws ecr describe-repositories --repository-names "${ECR_REPO}" --region "${AWS_REGION}" >/dev/null 2>&1 \
          || aws ecr create-repository --repository-name "${ECR_REPO}" --region "${AWS_REGION}"

      - name: Build & Push (tag = commit SHA)
        run: |
          set -e
          IMAGE_TAG="${GITHUB_SHA}"
          ECR_IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}"
          docker build -t "${ECR_IMAGE_URI}:${IMAGE_TAG}" .
          docker push "${ECR_IMAGE_URI}:${IMAGE_TAG}"
          echo "ECR_IMAGE_URI=${ECR_IMAGE_URI}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV

      - name: Get current task definition ARN
        id: curtd
        run: |
          ARN=$(aws ecs describe-services \
            --cluster "${CLUSTER}" \
            --services "${SERVICE}" \
            --region "${AWS_REGION}" \
            --query 'services[0].taskDefinition' --output text)
          echo "arn=$ARN" >> "$GITHUB_OUTPUT"

      - name: Download current task definition JSON
        run: |
          aws ecs describe-task-definition \
            --task-definition "${{ steps.curtd.outputs.arn }}" \
            --region "${AWS_REGION}" \
            --query 'taskDefinition' --output json > td.json
          echo "Current containers:"
          jq -r '.containerDefinitions[] | [.name,.image] | @tsv' td.json

      - name: Install jq (if missing)
        run: |
          command -v jq >/dev/null 2>&1 || { sudo apt-get update && sudo apt-get install -y jq; }

      - name: Replace container image only (preserve secrets/env)
        run: |
          set -e
          IMAGE="${ECR_IMAGE_URI}:${IMAGE_TAG}"
          NAME="${CONTAINER_NAME}"
          jq --arg IMG "$IMAGE" --arg NAME "$NAME" '
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes,
                .compatibilities, .registeredAt, .registeredBy)
            | .containerDefinitions =
                (if (.containerDefinitions | length) == 1
                 then [ (.containerDefinitions[0] * {image:$IMG}) ]
                 else (.containerDefinitions | map( if .name==$NAME then .image=$IMG else . end ))
                 end)
          ' td.json > td-new.json
          echo "Prepared containers:"
          jq -r '.containerDefinitions[] | [.name,.image] | @tsv' td-new.json

      - name: Register new task definition
        id: reg
        run: |
          NEW_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://td-new.json \
            --region "${AWS_REGION}" \
            --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "arn=$NEW_ARN" >> "$GITHUB_OUTPUT"
          echo "Registered: $NEW_ARN"

      - name: Update service to new task definition (rolling)
        run: |
          aws ecs update-service \
            --cluster "${CLUSTER}" \
            --service "${SERVICE}" \
            --task-definition "${{ steps.reg.outputs.arn }}" \
            --region "${AWS_REGION}"
          aws ecs wait services-stable \
            --cluster "${CLUSTER}" \
            --services "${SERVICE}" \
            --region "${AWS_REGION}"

      # --- 軽いスモークテスト（/openapi.json はそのまま） ---
      - name: Smoke test - /openapi.json
        run: |
          set -e
          curl -fsSL https://voice.frontglass.net/openapi.json | jq '.openapi,.info.title' >/dev/null

      # --- /twiml: 200 & XML系であれば合格（<?xml でも <Response でもOK） ---
      - name: Smoke test - /twiml returns XML-ish
        run: |
          set -e
          URL="https://voice.frontglass.net/twiml"
          # ヘッダも見たい時は -D で表示
          HTTP=$(curl -sS -H 'Accept: text/xml' -o /tmp/twiml.xml -w '%{http_code}' "$URL")
          echo "HTTP=$HTTP"
          head -n 2 /tmp/twiml.xml || true
          # ステータスチェック
          test "$HTTP" = "200"
          # 本文は XML 宣言 もしくは TwiML ルートが来ていればOK
          grep -Ei '^(<\?xml|<Response)' /tmp/twiml.xml >/dev/null
